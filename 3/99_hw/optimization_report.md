# До оптимизации:

![img.png](img.png)

# Профилирование
```shell
# Создание бинарника теста hw3.test.exe, 
# снятие профиля для CPU cpu.out,
# профиля для памяти mem.out с флагом -memprofilerate=1 (учитывать каждую аллокацию)
go test -bench='Slow' . -v -benchmem -cpuprofile='cpu.out' -memprofile='mem.out' -memprofilerate=1
```

```shell
# Просмотр результатов по процессору в web-интерфейсе
go tool pprof -http=:8080 .\hw3.test.exe .\cpu.out
```

```shell
# Просмотр результатов по памяти в web-интерфейсе
go tool pprof -http=:8080 .\hw3.test.exe .\mem.out
```
## CPU

![img_1.png](img_1.png)

Основные издержки приходятся на `json.Unmarshal` и `regexp.Compile`.

![img_2.png](img_2.png)

Из-за них происходит большое количество аллокаций, занимающих процессорное время.

![img_3.png](img_3.png)

Суммарно уходит почти секунда времени на `json.Unmarshal`.

![img_4.png](img_4.png)

Почти секунда на `regexp.MatchString`.

![img_5.png](img_5.png)

Еще раз почти секунда на `regexp.MatchString` спустя несколько строчек.

## Memory

![img_6.png](img_6.png)

Самые большие издержки по памяти приходятся на `regexp.MatchString`, `json.Unmarshal` и `ioutil.ReadAll`.

![img_7.png](img_7.png)![img_8.png](img_8.png)

Для выполнения `regexp.MatchString` требуется 40 и 26 МБ памяти.

![img_9.png](img_9.png)

На `json.Unmarshal` 10 МБ.

![img_10.png](img_10.png)

На чтение всего файла целиком и последующее разделение на строки 4 МБ.

# Резюме

1. Самой большой проблемой, как по памяти, так и по процессору являются regexp'ы (MatchString). В сущности происходит проверка, что в строке `browser` находится подстрока `"Android"` или `"MSIE"` соответственно. При этом происходят аллокации памяти, и тратится процессорное время. Можно прекомпилировать структуру для регулярного выражения, чтобы не делать это каждый раз в цикле. Но поскольку паттерн для регулярного выражения простой, можно заменить его на `strings.Contains`, который гораздо лучше:

![img_11.png](img_11.png)

После исправления получили следующие результаты: 

![img_12.png](img_12.png)

2. Следующей проблемой является `json.Unmarshal`, как по памяти, так и по процессору. Там происходит приведение к `map[string]interface{}`, из-за чего нужно будет приводить каждый интерфейс к конкретному типу. Бенчмарк показал, что `json.Unmarshal` в структуру работает лучше: 

![img_13.png](img_13.png)

`json.Unmarshal` в структуру работает быстрее, требует меньше аллокаций и памяти.

После исправления в коде: 

![img_14.png](img_14.png)

3. Использование другого Unmarshaler'а, использующего кодогенерацию, в данном случае `github.com/mailru/easyjson` улучшает работоспособность еще больше:

![img_15.png](img_15.png)

После исправления в коде: 

![img_16.png](img_16.png)

4. Вместо того чтобы целиком читать файл с помощью `ioutil.ReadAll`, можно попробовать читать его построчно и сразу обрабатывать. Таким образом не будет необходимости постоянно держать в памяти огромное количество данных. Плюс нам в действительности не нужно иметь массив строк - нам нужен массив массивов байт для десериализации пользователя.

![img_17.png](img_17.png)

Бенчмарк показывает, что это вдвое быстрее, и требует в 5 раз меньше памяти на операцию.

После исправления в коде:

![img_18.png](img_18.png)

# Профилирование после оптимизаций выше

## CPU

![img_20.png](img_20.png)

Самый большой упор идет на десериализацию данных, которую мы уже оптимизировали, и это занимает 80% времени процессора. 5% на чтение, и остальные 5% еще на регулярные выражения и на Sprintf. Возможно последние 5% можно улучшить.

![img_21.png](img_21.png)
![img_22.png](img_22.png)

## Memory

![img_23.png](img_23.png)

![img_24.png](img_24.png)
Регулярное выражение занимает память.

![img_25.png](img_25.png)

Происходит рост слайса пользователей.

![img_26.png](img_26.png)
![img_27.png](img_27.png)

Происходит рост слайса посещенных браузеров.

![img_28.png](img_28.png)

Требуется память для конкатенации строк foundUsers.

# Резюме 2

1. Слайс пользователей нам нужен только для того, чтобы по нему итерироваться. Тогда сам слайс нам не нужен, ведь можно использовать пользователя сразу, как мы его получили, не накапливая.

![img_29.png](img_29.png)

![img_30.png](img_30.png)

B/op уменьшилось на треть.

2. Вместо конкатенации строк `foundUsers` лучше использовать stringBuilder, т.к. при каждой конкатенации происходит выделение памяти под новую строку, содержащую старую + присоединяемую.

![img_31.png](img_31.png)

B/op уменьшилось еще на 20%.

3. В коде дважды проходят по одной и той же коллекции. Эти циклы можно объединить. Внутри каждого цикла проверяется, был ли какой-то браузер в слайсе `seenBrowsers`. Для этих целей лучше использовать мапу. 

![img_32.png](img_32.png)

![img_33.png](img_33.png)

Немного уменьшилось ns/op.

4. Для замены подстроки в строке лучше использовать `strings.ReplaceAll` вместо регулярного выражения:

![img_34.png](img_34.png)

![img_35.png](img_35.png)

Уменьшились B/op и allocs/op.